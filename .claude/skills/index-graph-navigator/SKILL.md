---
name: index-graph-navigator
description:
  Provides token-efficient navigation of PROJECT_INDEX.json for codebase analysis. Use when blast
  radius analysis, dead code detection, caller dependency analysis, or call stack tracing is needed.
  Mention 'blast radius', 'find callers', 'dead code', or provide file:line references to trigger.
  Primary consumer is AI agents requiring deterministic, minimal-token codebase navigation.
tools: Bash, Read
---

# Index Graph Navigator

**Token-efficient graph navigation for AI agents**

## Core Value Proposition

Instead of reading 20K-50K tokens of code to understand structure, query this skill and get 200-500
token JSON responses with exact file:line references.

**Token reduction**: 50-90% savings on codebase navigation tasks

---

## ⚠️ CRITICAL: When Invoked - FIRST ACTIONS

**NEVER read PROJECT_INDEX.json directly into context!**

When this skill is invoked, follow this exact workflow:

1. **Parse the user's request**
   - Identify query type (blast radius, dead code, callers, calls, hotspots, cycles)
   - Extract target (function name, file:line, or domain)

2. **Select and run the appropriate script**:

   ```bash
   # For impact analysis
   python3 ~/.claude/skills/index-graph-navigator/scripts/blast-radius.py "functionName"

   # For dead code detection
   bash ~/.claude/skills/index-graph-navigator/scripts/dead-code.sh --json

   # For reverse dependencies
   bash ~/.claude/skills/index-graph-navigator/scripts/find-callers.sh "functionName" --json

   # For forward dependencies
   bash ~/.claude/skills/index-graph-navigator/scripts/find-calls.sh "functionName" --json

   # For high-risk functions
   bash ~/.claude/skills/index-graph-navigator/scripts/hotspots.sh --limit 20 --json

   # For circular dependencies
   python3 ~/.claude/skills/index-graph-navigator/scripts/cycles.py

   # For coupling analysis
   python3 ~/.claude/skills/index-graph-navigator/scripts/cross-domain.py "domainName"

   # OR use dispatcher for natural language (recommended)
   python3 ~/.claude/skills/index-graph-navigator/scripts/query-dispatcher.py "user's natural language request"
   ```

3. **Parse JSON response** (200-500 tokens)

4. **Present results to user** with file:line references

**Why scripts only?** Scripts read only needed sections of PROJECT_INDEX.json (200-500 tokens)
instead of loading the entire file (26,000+ tokens) = **98% token reduction**

---

## Prerequisites

**Single Index File**: PROJECT_INDEX.json at project root

- Generated by `/index` command
- Contains entire codebase graph in one file
- Self-contained (no external domain files needed)

**Required Structure**:

- `.f` - Function definitions with file:line locations
- `.g` - Graph edges (caller relationships)
- `.d` - Dependencies
- `.stats` - Metadata (optional)

---

## How to Use This Skill

### Two Usage Modes

**Mode 1: Natural Language Dispatcher (Recommended for Complex Queries)**

When users need multi-step analysis or ambiguous requests, use the dispatcher:

```bash
python3 ~/.claude/skills/index-graph-navigator/scripts/query-dispatcher.py "{user's natural language request}"
```

The dispatcher will:

1. Parse the user's natural language request
2. Route to the appropriate script
3. Return JSON results (200-500 tokens)
4. Handle all errors gracefully

**Mode 2: Direct Script Execution (For Precise Queries)**

When you know the exact query type and parameters, call scripts directly:

```bash
# Find callers of a specific function
bash ~/.claude/skills/index-graph-navigator/scripts/find-callers.sh "functionName" --json

# Get hotspots with limit
bash ~/.claude/skills/index-graph-navigator/scripts/hotspots.sh --limit 20 --json

# Check blast radius
python3 ~/.claude/skills/index-graph-navigator/scripts/blast-radius.py "functionName"

# Find dead code
bash ~/.claude/skills/index-graph-navigator/scripts/dead-code.sh --json
```

**When to use each mode:**

- **Dispatcher**: User's intent unclear, multiple interpretations possible
- **Direct scripts**: You know exact query type, faster execution, clearer to debug

---

## Supported Query Types

The dispatcher automatically recognizes these query types from natural language:

| User Says                                   | Query Type       | Example                                |
| ------------------------------------------- | ---------------- | -------------------------------------- |
| "find hotspots", "most connected functions" | **hotspots**     | Top functions by caller count          |
| "who calls X", "find callers of X"          | **find-callers** | Direct reverse dependencies            |
| "what does X call", "X calls what"          | **find-calls**   | Direct forward dependencies            |
| "find dead code", "unused functions"        | **dead-code**    | Functions never called                 |
| "blast radius of X", "impact of changing X" | **blast-radius** | Transitive callers (all affected code) |
| "circular dependencies", "find cycles"      | **cycles**       | Circular dependency detection          |

---

## Usage Examples

See **@examples.md** for complete examples including:

- Finding hotspots and high-risk functions
- Caller/callee analysis
- Dead code detection
- Blast radius impact analysis
- Circular dependency detection
- Natural language query variations
- Error handling patterns

---

## Auto-Discovery Algorithm

The skill automatically finds PROJECT_INDEX.json at the project root:

**Search order**:

1. Find git root (or current directory)
2. Look for `PROJECT_INDEX.json` in project root
3. If not found, return error with hint to run `/index`

**Implementation**:

```bash
# Find project root
PROJECT_ROOT="$(git rev-parse --show-toplevel 2>/dev/null || pwd)"
INDEX_FILE="$PROJECT_ROOT/PROJECT_INDEX.json"

if [ ! -f "$INDEX_FILE" ]; then
  echo '{"status":"error","error":"PROJECT_INDEX.json not found","hint":"Run /index command"}'
  exit 1
fi
```

---

## Error Handling

All queries return structured JSON errors with helpful hints. See **@error-handling.md** for:

- Complete error response schemas
- Common error patterns (function not found, domain not found, PROJECT_INDEX.json missing)
- Recovery strategies and suggestions
- Best practices for error handling

---

## Advanced Options

### Limiting Results

User can specify limits in natural language:

```bash
python3 ~/.claude/skills/index-graph-navigator/scripts/query-dispatcher.py "top 20 hotspots"
# Extracts limit=20 automatically
```

### Function Name Formats

The dispatcher recognizes multiple formats:

- Backtick-wrapped: `functionName`
- "function X" syntax: "who calls function parseDate"
- camelCase/PascalCase detection: "who calls parseDate"

---

## Key Principles

✅ **ALWAYS DO**:

- Choose appropriate mode: dispatcher for ambiguous queries, direct scripts for precise needs
- Pass user's natural language request as argument (dispatcher mode)
- Parse JSON response and present results to user
- Show error hints from `hint` field to help user
- Verify PROJECT_INDEX.json exists before running queries

❌ **NEVER DO**:

- Read PROJECT_INDEX.json directly in context (defeats token efficiency)
- Implement graph algorithms yourself (use provided scripts)
- Skip error handling (scripts provide helpful messages)
- Assume index exists without checking (validate first)

---

## Reference Documentation

For detailed information about algorithms, query types, and integration patterns:

- **@query-library.md** - Complete documentation of all 8 query types
- **@graph-algorithms.md** - Python algorithm implementations
- **@integration-guide.md** - How other skills use this navigator

---

## Performance Characteristics

| Query Type   | Typical Time | Typical Tokens |
| ------------ | ------------ | -------------- |
| hotspots     | ~100ms       | 200-400        |
| find-callers | ~50ms        | 100-300        |
| find-calls   | ~50ms        | 100-300        |
| dead-code    | ~200ms       | 300-500        |
| blast-radius | ~300ms       | 400-600        |
| cycles       | ~500ms       | 300-500        |

All queries run in <1 second with token-minimal responses.

---

**Fast • Deterministic • Token-Efficient • Agent-Optimized**
